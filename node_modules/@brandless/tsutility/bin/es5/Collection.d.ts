export declare class Collection<T> implements Array<T> {
    private static _noReturn;
    constructor(...initialItems: T[]);
    $get$(index: number): T;
    $set$(index: number, value: T): any;
    flatMap: <U, This = undefined>(callback: (this: This, value: T, index: number, array: T[]) => U | readonly U[], thisArg?: This) => U[];
    flat: <U>(depth?: number) => any[];
    toLocaleString: () => string;
    concat: <U extends T[]>(...items: U[]) => T[];
    join: (separator?: string) => string;
    pop: () => T;
    push: (...items: T[]) => number;
    reverse: () => T[];
    includes: (searchElement: T, fromIndex?: number) => boolean;
    shift: () => T;
    slice: (start?: number, end?: number) => T[];
    sort: (compareFn?: (a: T, b: T) => number) => this;
    splice: (start?: number, deleteCount?: number, ...items: T[]) => T[];
    unshift: (...items: T[]) => number;
    indexOf: (searchElement: T, fromIndex?: number) => number;
    lastIndexOf: (searchElement: T, fromIndex?: number) => number;
    every: (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => boolean;
    some: (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => boolean;
    forEach: (callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any) => void;
    map: <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[];
    filter: (callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => T[];
    find: (predicate: any, thisArg?: any) => T;
    reduce: (callbackfn: any, initialValue?: any) => T;
    reduceRight: (callbackfn: any, initialValue?: any) => T;
    entries: () => IterableIterator<[number, T]>;
    keys: () => IterableIterator<number>;
    values: () => IterableIterator<T>;
    findIndex: (predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any) => number;
    fill: (value: T, start?: number, end?: number) => this;
    copyWithin: (target: number, start: number, end?: number) => this;
    length: number;
    [Symbol.unscopables]: () => {
        copyWithin: boolean;
        entries: boolean;
        fill: boolean;
        find: boolean;
        findIndex: boolean;
        keys: boolean;
        values: boolean;
    };
    [Symbol.iterator]: () => IterableIterator<T>;
    [n: number]: T;
}
